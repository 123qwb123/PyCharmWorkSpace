import math

#下面这是字典形式的存储(字典就是无序的)
movie_data = {"宝贝当家": [45, 2, 9, "喜剧片"],
              "美人鱼": [21, 17, 5, "喜剧片"],
              "澳门风云3": [54, 9, 11, "喜剧片"],
              "功夫熊猫3": [39, 0, 31, "喜剧片"],
              "谍影重重": [5, 2, 57, "动作片"],
              "叶问3": [3, 2, 65, "动作片"],
              "伦敦陷落": [2, 3, 55, "动作片"],
              "我的特工爷爷": [6, 4, 21, "动作片"],
              "奔爱": [7, 46, 4, "爱情片"],
              "夜孔雀": [9, 39, 8, "爱情片"],
              "代理情人": [9, 38, 2, "爱情片"],
              "新步步惊心": [8, 34, 17, "爱情片"]}

# 测试样本  唐人街探案": [23, 3, 17, "？片"]
#下面为求与数据集中所有数据的距离代码：
x = [23, 3, 17]
KNN = []
for key, v in movie_data.items():
    d = math.sqrt((x[0] - v[0]) ** 2 + (x[1] - v[1]) ** 2 + (x[2] - v[2]) ** 2)
#round()方法返回浮点数X的 四舍五入 值
#append() 方法用于在列表末尾添加新的对象
    KNN.append([key, round(d, 2)])


#我的测试（由测试可知，key和v分别对应于  "宝贝当家": [45, 2, 9, "喜剧片"] 中的 宝贝当家 和 [45, 2, 9, '喜剧片']）
    # print(key)
    # print(v)
    # print(v[3])
#我的测试====


# 输出所用电影到 唐人街探案的距离
print("===唐人街探案到其他所有电影的距离为：===")
#此处每次输出的结果都不同是因为没有排序的原因吗？？？
print(KNN)

#按照距离大小进行递增排序(下面的排序是根据第二个值（0,1）来排序的（此处的第二个值表示的是距离），后面的第二个值表示的是电影类别出现的次数)
KNN.sort(key=lambda dis: dis[1])

#选取距离最小的k个样本，这里取k=5；
KNN=KNN[:5]
print(KNN)

#确定前k个样本所在类别出现的频率，并输出出现频率最高的类别
labels = {"喜剧片":0,"动作片":0,"爱情片":0}
for s in KNN:
    #print(s)
    label = movie_data[s[0]]
    #label中存储的是（key,v）中对应的value的值
    #print(label)
    labels[label[3]] += 1   #把labels作为一个类似于计数的数组
    print(labels)
labels =sorted(labels.items(),key=lambda l: l[1],reverse=True)
print(labels,labels[0][0],sep='\n')
#我的测试
#print(labels[0][1])


#排序语法规则：https://www.cnblogs.com/huchong/p/8296025.html
# sort方法还有两个可选参数：key和reverse
# 1、key在使用时必须提供一个排序过程总调用的函数：（例如，len表示长度，fabs表示绝对值）
# 2、reverse实现降序排序，需要提供一个布尔值：（True为倒序排列，False为正序排列）